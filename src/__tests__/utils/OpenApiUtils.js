const SwaggerParser = require("@apidevtools/swagger-parser");
const fs = require("fs");
const OpenAPISampler = require("openapi-sampler");
const toSource = require("tosource");

const parser = new SwaggerParser();

const parseSchema = (response) => {
  if (
    response.content &&
    response.content["application/json"] &&
    response.content["application/json"].schema
  ) {
    const schema = response.content["application/json"].schema;
    return toSource(
      OpenAPISampler.sample(schema),
      undefined,
      "  ",
      "    "
    );
  }
  return "{}";
};

const parseResponse = (responses) => {
  const statusCodes = ["200", "201", "204"];
  for (const statusCode of statusCodes) {
    if (responses[statusCode]) {
      return [
        statusCode,
        parseSchema(responses[statusCode])
      ];
    }
  }
};

const templateMock = (
  method,
  path,
  request,
  statusCode,
  body
) => {
  const upperMethod = method.slice(0, 1).toUpperCase() + method.slice(1);
  const requestString = request !== undefined ? `, ${request}` : "";
  return `  mock.on${upperMethod}('${path}'${requestString}).reply(${statusCode},\n    ${body},\n  );\n`;
};

const templateMockError = (
  method,
  path,
  request
) => {
  const upperMethod = method.slice(0, 1).toUpperCase() + method.slice(1);
  const requestString = request !== undefined ? `, ${request}` : "";
  return `  mock.on${upperMethod}('${path}'${requestString}).networkError();\n`;
};

function getOutputFile(outputPath, suffix, fileName) {
  const basePath = outputPath.endsWith("/") ? outputPath + `${suffix}/` : outputPath + `/${suffix}/`;
  if (!fs.existsSync(basePath)) {
    fs.mkdirSync(basePath, { recursive: true });
  }
  return basePath + fileName + ".ts";
}

function generateMockData(api, outputPath) {
  for (const schemaKey in api.components.schemas) {
    const schema = api.components.schemas[schemaKey];
    const mockData = toSource(
      OpenAPISampler.sample(schema),
      undefined,
      "  ",
      "    "
    );

    const mock = schemaKey.slice(0, 1).toLowerCase() + schemaKey.slice(1);
    const mocks = [
      "// generated by generate-axios-mock-adapter \n",
      `const ${mock} = ${mockData};\n`,
      `export default ${mock};\n`
    ];

    fs.writeFileSync(
      getOutputFile(outputPath, "data", schemaKey),
      mocks.join("\n")
    );
  }
}

function generateAxiosMockErrors(api, host, outputPath) {
  const methods = ["get", "put", "post", "delete"];
  const mocks = [
    "// generated by generate-axios-mock-adapter",
    "import { AxiosInstance } from \"axios\";",
    "import MockAdapter from \"axios-mock-adapter\";\n",
    "const mockError = (axios: AxiosInstance) => {",
    "  const mock = new MockAdapter(axios);\n"
  ];
  for (const pathKey in api.paths) {
    const path = api.paths[pathKey];
    methods.forEach((method) => {
        const pathMethod = path[method];
        if (pathMethod && pathMethod.responses) {
          let request;
          if (pathMethod.requestBody) {
            request = parseSchema(
              pathMethod.requestBody
            );
          }
          mocks.push(
            templateMockError(
              method,
              (host || "") + pathKey,
              request
            )
          );
        }
      }
    );
  }
  mocks.push("};\n\nexport default mockError;\n");

  fs.writeFileSync(getOutputFile(outputPath, "axios/error", "AxiosMockAdapter"), mocks.join("\n"));
}

function generateAxiosMocks(api, host, outputPath) {
  const methods = ["get", "put", "post", "delete"];
  const mocks = [
    "// generated by generate-axios-mock-adapter",
    "import { AxiosInstance } from \"axios\";",
    "import MockAdapter from \"axios-mock-adapter\";\n",
    "const mockSuccess = (axios: AxiosInstance) => {",
    "  const mock = new MockAdapter(axios);\n"
  ];
  for (const pathKey in api.paths) {
    const path = api.paths[pathKey];
    methods.forEach((method) => {
      const pathMethod = path[method];
      if (pathMethod && pathMethod.responses) {
        const response = parseResponse(pathMethod.responses);
        let request;
        if (pathMethod.requestBody) {
          request = parseSchema(
            pathMethod.requestBody
          );
        }
        if (response) {
          mocks.push(
            templateMock(
              method,
              (host || "") + pathKey,
              request,
              response[0],
              response[1]
            )
          );
        }
      }
    });
  }
  mocks.push("};\n\nexport default mockSuccess;\n");

  fs.writeFileSync(getOutputFile(outputPath, "axios/success", "AxiosMockAdapter"), mocks.join("\n"));
}

const generateAxiosMockAdapter = (
  schemaFile,
  outputPath,
  host
) => {
  parser.dereference(schemaFile, (err, api) => {
    if (err) {
      console.error(err);
    } else if (api) {
      // Clear output directory only if it exists
      if (fs.existsSync(outputPath)) {
        fs.rmSync(outputPath, { recursive: true });
      }
      fs.mkdirSync(outputPath, { recursive: true });
      generateMockData(api, outputPath);
      generateAxiosMocks(api, host, outputPath);
      generateAxiosMockErrors(api, host, outputPath);
    }
  });
};

module.exports = generateAxiosMockAdapter;